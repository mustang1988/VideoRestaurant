@startuml Sequence Design

actor Client
entity Storage
entity Waiter
database Database
queue TaskQueue
entity Chef
entity Assistant
queue CallbackQueue

autonumber

group Phase Service Startup
    activate Chef
    Chef -> Chef: Startup service Chef, listening to a port, on websocket
    activate Assistant
    Assistant -> Assistant: Startup service Assistant
    Assistant -> Chef : Connecting to Chef, if success, send a regist message to Chef
    note left
    regist message:
    {
        type:'regist',
        ip:'Assistant IP'
    }
    end note
    Chef -> Chef : Generate a unique ID for Assistant whitch send a regist message to Chef
    Chef -> Database : Save Assistant info to database, set's status to IDEL
    note left
    INSERT INTO 
        tb_node(id,node_ip,status,node_registed_at) 
        VALUES('GeneratedID','Assistant IP',IDEL,Date.now())
    end note
    Chef -> Assistant : Send the unique id generated by Chef, to Assistant

    activate Waiter
    Waiter -> Waiter: Startup service Waiter, listening to a port, on GRPC

end

group Phase Task Creation
    Client -> Storage : Upload file to storage
    Client -> Waiter : Send a transcode request
    note right
    Transcode request:
    {
        callback:'Callback URL'
        file: 'File to transcode'
        ... // TODO
    }
    end note
    Waiter -> Waiter : Generate a unique id to transcode task
    Waiter -> Database : Save task info to database
    note right
    INSERT INTO
        tb_task(id,task_file,callback,status)
        VALUES('GeneratedID','File to transcode in request','Callback URL in request',QUEUING)
    end note
    Waiter -> TaskQueue : Push the task to task queue
    note right
    taskQueue.push({
        id:'GeneratedID',
        task_file: 'File to transcode in request',
    })
    end note
end

group Phase Task Execution
    Chef -> TaskQueue : Pull message from task queue
    Chef -> Storage : Read origin file's metadata using ffprobe
    note left
    ffprobe \
    -v \
    0 \
    -of \
    json \
    -show_streams \
    -show_format \
    -i 'source file'
    end note
    Chef -> Database : Save metadata info database
    note left
    UPDATE tb_task SET task_metadata='metadata' WHERE id='task id'
    end note
    Chef -> Chef : Analyze the metadata, build transcode args
    ' Chef -> Database : Save transcode args to database
    ' note left
    ' UPDATE tb_task SET task_args='transcode args' WHERE id='task id'
    ' end note
    Chef -> Chef : Seperate origin file into segments, segment count equals to how many assistants are IDEL
    Chef -> Database: Save segment info to database
    note left
    INSERT INTO 
        tb_job(id,job_task_id,job_node_id,job_status,job_retried,job_file,job_args,job_log)
        VALUES(...)
    end note
    Chef -> Assistant: Send job info to assistants
    note left
    ws.send({
        type:'job',
        id:'job id',
    })
    end note
    Assistant -> Chef : 收到作业指派后回报指派接收状态
    Chef -> Database : 根据分片作业ID, 更新分片作业信息, Storage分片任务指派到的AssistantID
    Assistant -> Assistant: 执行分片转码作业
    Assistant -> Chef : 作业完成后, 上报分片转码作业状态
    Chef -> Database: 根据分片作业ID更新Database中的分片作业状态
    Chef -> Chef : 合并分片转码作业的输出
    Chef -> Database: 根据任务ID更新Database中的任务状态
    Chef -> CallbackQueue : 将转码结果放入CallbackQueue
end

group Phase Callback Notification
    Waiter -> CallbackQueue : 从CallbackQueue中读取任务信息
    Waiter -> Database : 根据任务ID, 从Database读取转码结果和回调地址
    Waiter -> Client : 通过回调地址发送任务结果到Client
end

@enduml